{
	"APIDto": {
		"prefix": "apidto",
		"body": [
			"/**\r",
			" * API Representation of [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object\r",
			" */\r",
			"export interface ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dto {\r",
			"    id: number\r",
			"    //DON'T FORGET OTHER ATTRIBUTES",
			"    createdAt: Date\r",
			"    updatedAt: Date\r",
			"    deletedAt?: Date \r",
			"}"
		],
		"description": "Object transfered by API"
	},
	"APIService": {
		"prefix": "apiservice",
		"body": [
			"/**\r",
			" * [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] service between API and DB\r",
			" */\r",
			"\r",
			"/**\r",
			" * Ask db to create new [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] type\r",
			" * @param payload \r",
			" * @returns \r",
			" */\r",
			"export const create = (payload: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.create(payload)\r",
			"}\r",
			"\r",
			"/**\r",
			" * Ask db to get [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object by its id\r",
			" * @param name \r",
			" * @returns \r",
			" */\r",
			"export const getByName = (name: string): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output | null> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.getByName(name)\r",
			"}\r",
			"\r",
			"/**\r",
			" * Ask db to get all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects\r",
			" * @param filters \r",
			" * @returns \r",
			" */\r",
			"export const getAll = (filters: ListFilters): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output[]> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.getAll(filters)\r",
			"}"
		],
		"description": "Service used for communication between API and DB"
	},
	"APIModel": {
		"prefix": "apimodel",
		"body": [
			"import { DataTypes,Model, Optional } from \"sequelize/types\";\r",
			"import sequelizeConnection from \"../db.config\";\r",
			"/**\r",
			" * [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] model on db (by SequelizeORM)\r",
			" */\r",
			"\r",
			"interface ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes {\r",
			"  id: number;\r",
			"  //DON'T FORGET OTHER ATTRIBUTES",
			"  createdAt?: Date;\r",
			"  updatedAt?: Date;\r",
			"  deletedAt?: Date;\r",
			"}\r",
			"//What came from User\r",
			"export interface ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input extends Optional<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes, 'id'> {}\r",
			"//What give to User\r",
			"export interface ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output extends Required<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes> {}\r",
			"\r",
			"//Typescript class\r",
			"class ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} extends Model<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes,${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input> implements ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes {\r",
			"    public id!: number;\r",
			"    //DON'T FORGET OTHER ATTRIBUTES",
			"    public readonly createdAt!: Date;\r",
			"    public readonly updatedAt!: Date;\r",
			"    public readonly deletedAt!: Date;\r",
			"\r",
			"}\r",
			"\r",
			"//Sequelize class\r",
			"${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.init({\r",
			"    id: {\r",
			"        type: DataTypes.INTEGER,\r",
			"        autoIncrement: true,\r",
			"        primaryKey: true,\r",
			"    },\r",
			"    //DON'T FORGET OTHER ATTRIBUTES",
			"},\r",
			"{\r",
			"    timestamps: true,\r",
			"    // //!\\ BE CAREFUL -> table name is plural by default, sometimes, you don't want it (ex:Child,Glass...)",
			"    tableName: \"${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}s\",\r",
			"    sequelize: sequelizeConnection,\r",
			"    paranoid: true //Avoid to definitely delete records (property deletedAt)\r",
			"})\r",
			"\r",
			"/**\r",
			" * Here is the associations with [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}]\r",
			" */\r",
			"\r",
			"export default ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/};"
		],
		"description": "Object transfered by db"
	},
	"APIDao": {
		"prefix": "apidao",
		"body": [
			"import {Op} from 'sequelize'\r",
			"import ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}, { ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input, ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output } from '../models/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}'\r",
			"import { ListFilters } from './types';\r",
			"\r",
			"/**\r",
			" * [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] Data Access from db with SequelizeORM\r",
			" */\r",
			"\r",
			"/**\r",
			" * Create a new [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object\r",
			" * @param payload \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] n°Id\r",
			" */\r",
			"export const create = async (payload: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output> => {\r",
			"    const created${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.create(payload)\r",
			"    return created${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/};\r",
			"}\r",
			"\r",
			"/**\r",
			" * Update [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object by its id\r",
			" * @param payload \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] n°Id\r",
			" */\r",
			" export const update = async (id: number, payload: Partial<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input>): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output | null> => {\r",
			"    const searched${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.findByPk(id);\r",
			"    if(!searched${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}){\r",
			"        throw new Error(`[${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] n°${id} non trouvée`)\r",
			"    }\r",
			"    const updated${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await(searched${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} as ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}).update(payload);\r",
			"\r",
			"    return updated${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/};\r",
			"}\r",
			"\r",
			"/**\r",
			" * Get [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] by its id\r",
			" * @param id \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] n°Id\r",
			" */\r",
			"export const getById = async (id: number): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output | null> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.findByPk(id)\r",
			"}\r",
			"\r",
			"/**\r",
			" * Get all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects by filters\r",
			" * @param filters \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] records\r",
			" */\r",
			"export const getAll = async (filters?: ListFilters): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output[]> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.findAll({\r",
			"        where: {\r",
			"            ...(filters?.isDeleted && {deletedAt: {[Op.not]: null}})\r",
			"        },\r",
			"        ...((filters?.isDeleted || filters?.includeDeleted) && {paranoid: true})\r",
			"    })\r",
			"}\r",
			"\r",
			"/**\r",
			" * Count all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects by filters\r",
			" * @param filters \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] numbers\r",
			" */\r",
			" export const countAll = async (filters?: ListFilters): Promise<number> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.count({\r",
			"        where: {\r",
			"            ...(filters?.isDeleted && {deletedAt: {[Op.not]: null}})\r",
			"        },\r",
			"        ...((filters?.isDeleted || filters?.includeDeleted) && {paranoid: true})\r",
			"    })\r",
			"}\r",
			"\r",
			"/**\r",
			" * Delete [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] by its id\r",
			" * @param id \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] is deleted\r",
			" */\r",
			" export const deleteById = async (id: number): Promise<boolean> => {\r",
			"    const deleted${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.destroy({\r",
			"        where: {id}\r",
			"    })\r",
			"\r",
			"    return !!deleted${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/};\r",
			"}"
		],
		"description": "Methods to access the objects in db"
	},
	"APIContract": {
		"prefix": "apicontract",
		"body": [
			"//import { Optional } from \"sequelize/types\"\r",
			"\r",
			"/**\r",
			" * Contracts with API when using [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] routes\r",
			" */\r",
			"\r",
			"/**\r",
			" * What to send to API when CREATE [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] = [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] attributes required for CREATION\r",
			" */\r",
			"export type Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = {\r",
			"    //ATTRIBUTES ASKED TO CREATE [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}]\r",
			"}\r",
			"\r",
			"/**\r",
			" * What to send to API when UPDATE [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] = some [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] attributes to UPDATE\r",
			" */\r",
			"// FOR USE CREATE CONTRACT PARTIALLY :\r",
			"//export type Update${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = Optional<Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract, ''>\r",
			"// FOR USE SAME CONTRACT THAN CREATION CONTRACT :\r",
			"export type Update${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract\r",
			"\r",
			"/**\r",
			" * What to send to API when GET [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] by its id => USED BY GET,UPDATE,DELETE\r",
			" */\r",
			"export type ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}IdContract = {\r",
			"    id: number;\r",
			"}\r",
			"\r",
			"/**\r",
			" * What filters to send to API when GET OR COUNT ALL [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] by filters\r",
			" */\r",
			"export type Filter${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = {\r",
			"}"
		],
		"description": "Define the contracts used between User and API"
	},
	"APIController": {
		"prefix": "apicontroller",
		"body": [
			"import { MerOutput } from \"../../db/models/Mer\"\r",
			"import { CreateMerContract, FilterMerContract, UpdateMerContract } from \"../contracts/Mer.contract\"\r",
			"import { MerDto } from \"../dto/Mer.dto\"\r",
			"import * as service from '../services/Mer.service'\r",
			"\r",
			"/**\r",
			" * Convert db [Mer] model to [Mer] api model\r",
			" * @param Mer \r",
			" * @returns \r",
			" */\r",
			"export const toMer = (Mer: MerOutput): MerDto => {\r",
			"    return {\r",
			"        id: Mer.id,\r",
			"        createdAt: Mer.createdAt,\r",
			"        updatedAt: Mer.updatedAt,\r",
			"        deletedAt: Mer.deletedAt,\r",
			"    }\r",
			"}\r",
			"\r",
			"/**\r",
			" * Create new [Mer] defined by user\r",
			" * @param payload \r",
			" * @returns \r",
			" */\r",
			"export const create = async(payload: CreateMerContract): Promise<MerDto> => {\r",
			"    return toMer(await service.create(payload))\r",
			"}\r",
			"\r",
			"/**\r",
			" * Update [Mer] requested by user\r",
			" * @param id \r",
			" * @returns \r",
			" */\r",
			"export const updateById = async (id: number, payload: UpdateMerContract): Promise<MerDto | null> => {\r",
			"    const foundMer = await service.updateById(id,payload);\r",
			"    if(foundMer){\r",
			"        return toMer(foundMer);\r",
			"    }\r",
			"    else{\r",
			"        return null;\r",
			"    }\r",
			"}\r",
			"\r",
			"/**\r",
			" * Get [Mer] requested by user\r",
			" * @param id \r",
			" * @returns \r",
			" */\r",
			"export const getById = async (id: number): Promise<MerDto | null> => {\r",
			"    const foundMer = await service.getById(id);\r",
			"    if(foundMer){\r",
			"        return toMer(foundMer);\r",
			"    }\r",
			"    else{\r",
			"        return null;\r",
			"    }\r",
			"}\r",
			"\r",
			"/**\r",
			" * Get all [Mer] requested by user\r",
			" * @param filters \r",
			" * @returns \r",
			" */\r",
			"export const getAll = async(filters: FilterMerContract): Promise<MerDto[]> => {\r",
			"    return (await service.getAll(filters)).map(toMer)\r",
			"}\r",
			"\r",
			"/**\r",
			" * Count all [Mer] requested by user\r",
			" * @param filters \r",
			" * @returns \r",
			" */\r",
			"export const countAll = async(filters: FilterMerContract): Promise<number> => {\r",
			"    return (await service.countAll(filters))\r",
			"}\r",
			"\r",
			"/**\r",
			" * Delete [Mer] requested by user\r",
			" * @param id \r",
			" * @returns \r",
			" */\r",
			"export const deleteById = async (id: number): Promise<boolean> => {\r",
			"    return (await service.deleteById(id));\r",
			"}"
		],
		"description": "Default controllers for CRUD API"
	}
}