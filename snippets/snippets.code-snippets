{
	"APIDto": {
		"prefix": "apidto",
		"body": [
			"/**\r",
			" * API Representation of [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object\r",
			" */\r",
			"export interface ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dto {\r",
			"    id: number\r",
			"    //DON'T FORGET OTHER ATTRIBUTES",
			"    createdAt: Date\r",
			"    updatedAt: Date\r",
			"    deletedAt?: Date \r",
			"}"
		],
		"description": "Object transfered by API"
	},
	"APIModel": {
		"prefix": "apimodel",
		"body": [
			"import { DataTypes,Model, Optional } from \"sequelize/types\";\r",
			"import sequelizeConnection from \"../db.config\";\r",
			"/**\r",
			" * [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] model on db (by SequelizeORM)\r",
			" */\r",
			"\r",
			"interface ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes {\r",
			"  id: number;\r",
			"  //DON'T FORGET OTHER ATTRIBUTES",
			"  createdAt?: Date;\r",
			"  updatedAt?: Date;\r",
			"  deletedAt?: Date;\r",
			"}\r",
			"//What came from User\r",
			"export interface ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input extends Optional<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes, 'id'> {}\r",
			"//What give to User\r",
			"export interface ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output extends Required<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes> {}\r",
			"\r",
			"//Typescript class\r",
			"class ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} extends Model<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes,${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input> implements ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Attributes {\r",
			"    public id!: number;\r",
			"    //DON'T FORGET OTHER ATTRIBUTES",
			"    public readonly createdAt!: Date;\r",
			"    public readonly updatedAt!: Date;\r",
			"    public readonly deletedAt!: Date;\r",
			"\r",
			"}\r",
			"\r",
			"//Sequelize class\r",
			"${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.init({\r",
			"    id: {\r",
			"        type: DataTypes.INTEGER,\r",
			"        autoIncrement: true,\r",
			"        primaryKey: true,\r",
			"    },\r",
			"    //DON'T FORGET OTHER ATTRIBUTES",
			"},\r",
			"{\r",
			"    timestamps: true,\r",
			"    // //!\\ BE CAREFUL -> table name is plural by default, sometimes, you don't want it (ex:Child,Glass...)",
			"    tableName: \"${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}s\",\r",
			"    sequelize: sequelizeConnection,\r",
			"    paranoid: true //Avoid to definitely delete records (property deletedAt)\r",
			"})\r",
			"\r",
			"/**\r",
			" * Here is the associations with [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}]\r",
			" */\r",
			"\r",
			"export default ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/};"
		],
		"description": "Object transfered by db"
	},
	"APIDao": {
		"prefix": "apidao",
		"body": [
			"import {Op} from 'sequelize'\r",
			"import ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}, { ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input, ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output } from '../models/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}'\r",
			"import { ListFilters } from './types';\r",
			"\r",
			"/**\r",
			" * [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] Data Access from db with SequelizeORM\r",
			" */\r",
			"\r",
			"/**\r",
			" * Create a new [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object\r",
			" * @param payload \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] n°Id\r",
			" */\r",
			"export const create = async (payload: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output> => {\r",
			"    const created${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.create(payload)\r",
			"    return created${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/};\r",
			"}\r",
			"\r",
			"/**\r",
			" * Update [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object by its id\r",
			" * @param payload \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] n°Id\r",
			" */\r",
			" export const update = async (id: number, payload: Partial<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input>): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output | null> => {\r",
			"    const searched${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.findByPk(id);\r",
			"    if(!searched${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}){\r",
			"        throw new Error(`[${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] n°${id} non trouvée`)\r",
			"    }\r",
			"    const updated${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await(searched${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} as ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}).update(payload);\r",
			"\r",
			"    return updated${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/};\r",
			"}\r",
			"\r",
			"/**\r",
			" * Get [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] by its id\r",
			" * @param id \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] n°Id\r",
			" */\r",
			"export const getById = async (id: number): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output | null> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.findByPk(id)\r",
			"}\r",
			"\r",
			"/**\r",
			" * Get all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects by filters\r",
			" * @param filters \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] records\r",
			" */\r",
			"export const getAll = async (filters?: ListFilters): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output[]> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.findAll({\r",
			"        where: {\r",
			"            ...(filters?.isDeleted && {deletedAt: {[Op.not]: null}})\r",
			"        },\r",
			"        ...((filters?.isDeleted || filters?.includeDeleted) && {paranoid: true})\r",
			"    })\r",
			"}\r",
			"\r",
			"/**\r",
			" * Count all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects by filters\r",
			" * @param filters \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] numbers\r",
			" */\r",
			" export const countAll = async (filters?: ListFilters): Promise<number> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.count({\r",
			"        where: {\r",
			"            ...(filters?.isDeleted && {deletedAt: {[Op.not]: null}})\r",
			"        },\r",
			"        ...((filters?.isDeleted || filters?.includeDeleted) && {paranoid: true})\r",
			"    })\r",
			"}\r",
			"\r",
			"/**\r",
			" * Delete [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] by its id\r",
			" * @param id \r",
			" * @returns [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] is deleted\r",
			" */\r",
			" export const deleteById = async (id: number): Promise<boolean> => {\r",
			"    const deleted${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.destroy({\r",
			"        where: {id}\r",
			"    })\r",
			"\r",
			"    return !!deleted${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/};\r",
			"}"
		],
		"description": "Methods to access the objects in db"
	},
	"APIContract": {
		"prefix": "apicontract",
		"body": [
			"//import { Optional } from \"sequelize/types\"\r",
			"\r",
			"/**\r",
			" * Contracts with API when using [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] routes\r",
			" */\r",
			"\r",
			"/**\r",
			" * What to send to API when CREATE [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] = [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] attributes required for CREATION\r",
			" */\r",
			"export type Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = {\r",
			"    //ATTRIBUTES ASKED TO CREATE [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}]\r",
			"}\r",
			"\r",
			"/**\r",
			" * What to send to API when UPDATE [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] = some [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] attributes to UPDATE\r",
			" */\r",
			"// FOR USE CREATE CONTRACT PARTIALLY :\r",
			"//export type Update${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = Optional<Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract, ''>\r",
			"// FOR USE SAME CONTRACT THAN CREATION CONTRACT :\r",
			"export type Update${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract\r",
			"\r",
			"/**\r",
			" * What to send to API when GET [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] by its id => USED BY GET,UPDATE,DELETE\r",
			" */\r",
			"export type ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}IdContract = {\r",
			"    id: number;\r",
			"}\r",
			"\r",
			"/**\r",
			" * What filters to send to API when GET OR COUNT ALL [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] by filters\r",
			" */\r",
			"export type Filter${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = {\r",
			"}"
		],
		"description": "Define the contracts used between User and API"
	},
	"APIController": {
		"prefix": "apicontroller",
		"body": [
			"import { ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output } from \"../../db/models/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}\"\r",
			"import { Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract, Filter${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract, Update${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract } from \"../contracts/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.contract\"\r",
			"import { ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dto } from \"../dto/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.dto\"\r",
			"import * as service from '../services/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.service'\r",
			"\r",
			"/**\r",
			" * Convert db [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] model to [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] api model\r",
			" * @param ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} \r",
			" * @returns \r",
			" */\r",
			"export const to${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = (${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output): ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dto => {\r",
			"    return {\r",
			"        id: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.id,\r",
			"        createdAt: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.createdAt,\r",
			"        updatedAt: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.updatedAt,\r",
			"        deletedAt: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.deletedAt,\r",
			"    }\r",
			"}\r",
			"\r",
			"/**\r",
			" * Create new [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] defined by user\r",
			" * @param payload \r",
			" * @returns \r",
			" */\r",
			"export const create = async(payload: Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dto> => {\r",
			"    return to${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}(await service.create(payload))\r",
			"}\r",
			"\r",
			"/**\r",
			" * Update [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] requested by user\r",
			" * @param id \r",
			" * @returns \r",
			" */\r",
			"export const updateById = async (id: number, payload: Update${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dto | null> => {\r",
			"    const found${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await service.updateById(id,payload);\r",
			"    if(found${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}){\r",
			"        return to${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}(found${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/});\r",
			"    }\r",
			"    else{\r",
			"        return null;\r",
			"    }\r",
			"}\r",
			"\r",
			"/**\r",
			" * Get [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] requested by user\r",
			" * @param id \r",
			" * @returns \r",
			" */\r",
			"export const getById = async (id: number): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dto | null> => {\r",
			"    const found${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/} = await service.getById(id);\r",
			"    if(found${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}){\r",
			"        return to${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}(found${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/});\r",
			"    }\r",
			"    else{\r",
			"        return null;\r",
			"    }\r",
			"}\r",
			"\r",
			"/**\r",
			" * Get all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] requested by user\r",
			" * @param filters \r",
			" * @returns \r",
			" */\r",
			"export const getAll = async(filters: Filter${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dto[]> => {\r",
			"    return (await service.getAll(filters)).map(to${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/})\r",
			"}\r",
			"\r",
			"/**\r",
			" * Count all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] requested by user\r",
			" * @param filters \r",
			" * @returns \r",
			" */\r",
			"export const countAll = async(filters: Filter${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract): Promise<number> => {\r",
			"    return (await service.countAll(filters))\r",
			"}\r",
			"\r",
			"/**\r",
			" * Delete [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] requested by user\r",
			" * @param id \r",
			" * @returns \r",
			" */\r",
			"export const deleteById = async (id: number): Promise<boolean> => {\r",
			"    return (await service.deleteById(id));\r",
			"}"
		],
		"description": "Default controllers for CRUD API"
	},
	"APIService": {
		"prefix": "apiservice",
		"body": [
			"import { ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input, ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output } from \"../../db/models/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}\"\r",
			"import * as ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao from '../../db/dao/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.dao'\r",
			"import { ListFilters } from \"../../db/dao/types\"\r",
			"\r",
			"/**\r",
			" * [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] service between API and DB\r",
			" */\r",
			"\r",
			"/**\r",
			" * Ask db to create new [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] type\r",
			" * @param payload \r",
			" * @returns \r",
			" */\r",
			"export const create = (payload: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.create(payload)\r",
			"}\r",
			"\r",
			"/**\r",
			" * Ask db to update [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object of id specified\r",
			" * @param id\r",
			" * @returns \r",
			" */\r",
			"export const updateById = (id: number, payload: ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Input): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output | null> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.update(id,payload);\r",
			"}\r",
			"\r",
			"/**\r",
			" * Ask db to get [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object of id specified\r",
			" * @param id\r",
			" * @returns \r",
			" */\r",
			"export const getById = (id: number): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output | null> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.getById(id);\r",
			"}\r",
			"\r",
			"/**\r",
			" * Ask db to get all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects\r",
			" * @param filters \r",
			" * @returns \r",
			" */\r",
			"export const getAll = (filters: ListFilters): Promise<${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Output[]> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.getAll(filters)\r",
			"}\r",
			"\r",
			"/**\r",
			" * Ask db to count all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects matching filters\r",
			" * @param filters \r",
			" * @returns \r",
			" */\r",
			"export const countAll = (filters: ListFilters): Promise<number> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.countAll(filters)\r",
			"}\r",
			"\r",
			"/**\r",
			" * Ask db to delete [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] object of id specified\r",
			" * @param id\r",
			" * @returns \r",
			" */\r",
			" export const deleteById = (id: number): Promise<boolean> => {\r",
			"    return ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Dao.deleteById(id);\r",
			"}"
		],
		"description": "Service used for communication between API and DB"
	},
	"APIRoute": {
		"prefix": "apiroute",
		"body": [
			"import {  Router, Request,Response } from 'express'\r",
			"import { Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract, Filter${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract } from '../contracts/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.contract'\r",
			"import * as ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Controller from '../controllers/${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}.controller'\r",
			"\r",
			"const ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Router = Router()\r",
			"\r",
			"/**\r",
			" * Create new [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}]\r",
			" */\r",
			" ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Router.post('/', async (req: Request, res: Response) => {\r",
			"    const payload:Create${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = req.body\r",
			"    const result = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Controller.create(payload).catch(error => { error : res.status(500).send(\"Une erreur est survenue à la création de la source : \"+ error.message) })\r",
			"    return res.status(200).send(result)\r",
			"})\r",
			"\r",
			"/**\r",
			" * Update [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] of id specified\r",
			" */\r",
			"${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Router.put('/:id', async (req: Request, res: Response) => {\r",
			"    const id = Number(req.params.id)\r",
			"    const result = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Controller.updateById(id,req.body)\r",
			"    return res.status(200).send(result)\r",
			"})\r",
			"\r",
			"/**\r",
			" * Delete [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] of id specified\r",
			" */\r",
			"${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Router.delete('/:id', async (req: Request, res: Response) => {\r",
			"    const id = Number(req.params.id)\r",
			"    const result = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Controller.deleteById(id)\r",
			"    return res.status(200).send(result)\r",
			"})\r",
			"\r",
			"/**\r",
			" * Get [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] of id specified\r",
			" */\r",
			" ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Router.get('/:id', async (req: Request, res: Response) => {\r",
			"    const id = Number(req.params.id)\r",
			"    const result = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Controller.getById(id)\r",
			"    return res.status(200).send(result)\r",
			"})\r",
			"\r",
			"/**\r",
			" * Get all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects\r",
			" */\r",
			" ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Router.get('/', async (req: Request, res: Response) => {\r",
			"    const filters:Filter${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = req.query\r",
			"    const results = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Controller.getAll(filters)\r",
			"    return res.status(200).send(results)\r",
			"})\r",
			"\r",
			"/**\r",
			" * Count all [${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}] objects\r",
			" */\r",
			" ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Router.get('/count', async (req: Request, res: Response) => {\r",
			"    const filters:Filter${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Contract = req.query\r",
			"    const results = await ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Controller.countAll(filters)\r",
			"    return res.status(200).send(results)\r",
			"})\r",
			"\r",
			"export default ${TM_FILENAME_BASE/([^.]+).*/${1:/capitalize}/}Router"
		],
		"description": "Default routes for CRUD API"
	}
}